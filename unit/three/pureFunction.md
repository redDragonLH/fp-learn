# 纯函数

> 相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用

纯函数的结果不能依靠外部变量,不能取决于系统状态

> 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互

副作用可能包含，但不限于

* 更改文件系统
* 往数据库插入记录
* 发送一个http 请求
* 可变数据
* 打印/log
* 获取用户输入
* DOM查询
* 访问系统状态

`概括来讲，只要是跟函数外部环境发生的交互就都是副作用`

**函数式编程的哲学就是假定副作用是造成不正当行为的主要原因**

副作用让一个函数变得不纯是有道理的：从定义上来说，纯函数必须要能够根据相同的输入返回相同的输出；如果函数需要跟外部事物打交道，那么就无法保证这一点了。

## ‘八年级数学’
根据 mathisfun.com：
> 函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。


换句话说，函数只是两种数值之间的关系：输入和输出。尽管每个输入都只会有一个输出，但不同的输入却可以有相同的输出

函数就是数学上的函数，而且是函数式编程的全部

## 追求纯的好处

### 可缓存性 （Cacheable）
纯函数总能够根据输入来做缓存

### 可移植性/自文档化(Portable / Self-Documenting)

纯函数的依赖很明确

纯函数对于其依赖必须要诚实，这样我们就能知道函数 的目的，相比不纯的函数，纯函数能够提供多得多的信息

在 JavaScript 的设定中，可移植性可以意味着把函数序列化（serializing）并通过 socket 发送。也可以意味着代码能够在 web workers 中运行。总之，可移植性是一个非常强大的特性。

```
命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。
```
## 可测试性（Testable）
，纯函数让测试更加容易。我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。
## 合理性（Reasonable）
纯函数 引用透明

>如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的

由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性
## 并行代码
我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。
并行代码在服务端 js 环境以及使用了 web worker 的浏览器那里是非常容易实现的，因为它们使用了线程（thread）。不过出于对非纯函数复杂度的考虑，当前主流观点还是避免使用这种并行。